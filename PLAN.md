# План реализации Telegram-бота FindOrigin

## Этап 1: Настройка проекта и инфраструктуры

### 1.1 Инициализация Next.js проекта
- Создать новый Next.js проект с TypeScript
- Настроить структуру папок (app router или pages router)
- Установить необходимые зависимости

### 1.2 Настройка окружения
- Создать файл `.env.local` для хранения секретов
- Добавить переменные окружения:
  - `TELEGRAM_BOT_TOKEN` - токен бота от BotFather
  - `TELEGRAM_WEBHOOK_SECRET` - секретный ключ для верификации webhook
  - `AI_API_KEY` - ключ для AI API (OpenAI, Anthropic и т.д.)
  - `SEARCH_API_KEY` - ключ для поискового API (Google Custom Search, SerpAPI и т.д.)

### 1.3 Настройка Vercel
- Подготовить `vercel.json` для конфигурации деплоя
- Настроить переменные окружения в Vercel Dashboard

## Этап 2: Реализация Webhook обработчика

### 2.1 Создание API route для webhook
- Создать endpoint `/api/webhook` (POST)
- Реализовать быструю обработку входящих обновлений от Telegram
- Извлечение `chat.id` и `text` из `update.message`
- Валидация входящих данных
- Возврат 200 OK без долгих операций

### 2.2 Интеграция с Telegram API
- Создать утилиту для отправки сообщений через Telegram Bot API
- Реализовать метод `sendMessage` для отправки ответов пользователю
- Обработка ошибок при отправке сообщений

### 2.3 Настройка webhook в Telegram
- Создать скрипт или инструкцию для установки webhook URL
- Реализовать endpoint для установки webhook (опционально)

## Этап 3: Обработка входящих данных

### 3.1 Парсинг текста
- Реализовать функцию для извлечения текста из обычного сообщения
- Реализовать функцию для извлечения текста из ссылки на Telegram-пост
- Обработка различных форматов ссылок (t.me/channel/123, telegram.me и т.д.)

### 3.2 Извлечение ключевых элементов
- Реализовать парсер для выделения:
  - Ключевых утверждений (используя NLP или простые эвристики)
  - Дат (регулярные выражения или библиотеки для парсинга дат)
  - Чисел (статистика, проценты, суммы)
  - Имен собственных (имена людей, организаций, мест)
  - Ссылок (URL в тексте)

### 3.3 Обработка ошибок
- Обработка некорректных ссылок
- Обработка недоступных постов
- Обработка пустых или некорректных сообщений

## Этап 4: Поиск источников

### 4.1 Выбор поискового API
- Интегрировать поисковый API (Google Custom Search, SerpAPI, Bing Search API)
- Создать функцию для формирования поисковых запросов на основе извлеченных данных
- Реализовать функцию для выполнения поисковых запросов

### 4.2 Фильтрация результатов
- Реализовать логику фильтрации по типам источников:
  - Официальные сайты (правительственные, образовательные)
  - Новостные сайты (проверенные источники)
  - Блоги и независимые издания
  - Исследования и научные публикации
- Приоритизация результатов по релевантности

### 4.3 Сбор данных из источников
- Реализовать функцию для извлечения текста со страниц источников
- Обработка различных форматов (HTML, PDF и т.д.)
- Обработка ошибок при доступе к источникам

## Этап 5: AI-анализ и сравнение

### 5.1 Интеграция AI API
- Выбрать AI провайдера (OpenAI GPT, Anthropic Claude, и т.д.)
- Создать функцию для отправки запросов к AI API
- Реализовать промпты для сравнения смысла текстов

### 5.2 Сравнение смысла
- Реализовать функцию для сравнения исходного текста с текстами из источников
- Использовать AI для семантического сравнения (не буквального)
- Извлечение ключевых совпадений и различий

### 5.3 Оценка уверенности
- Реализовать систему оценки уверенности (0-100% или 0-1)
- Учет факторов:
  - Степень совпадения смысла
  - Надежность источника
  - Количество подтверждающих источников
  - Временная релевантность

## Этап 6: Формирование ответа

### 6.1 Структурирование результатов
- Отбор 1-3 наиболее релевантных источников
- Форматирование результатов с оценкой уверенности
- Подготовка текста ответа для пользователя

### 6.2 Отправка ответа
- Форматирование сообщения в удобочитаемом виде
- Включение ссылок на источники
- Отображение оценки уверенности
- Отправка асинхронно (после возврата 200 OK)

## Этап 7: Асинхронная обработка

### 7.1 Реализация очереди задач
- Настроить систему очередей (Vercel Queue, Upstash Redis, или встроенное решение)
- Разделение на быстрый ответ (200 OK) и долгую обработку
- Обработка задач в фоновом режиме

### 7.2 Управление состоянием
- Отслеживание статуса обработки запросов
- Возможность отправки промежуточных сообщений пользователю
- Обработка таймаутов и ошибок

## Этап 8: Тестирование и оптимизация

### 8.1 Модульное тестирование
- Тесты для парсинга текста
- Тесты для извлечения ключевых элементов
- Тесты для поиска источников
- Тесты для AI-сравнения

### 8.2 Интеграционное тестирование
- Тестирование полного потока обработки
- Тестирование webhook обработчика
- Тестирование с реальными данными

### 8.3 Оптимизация производительности
- Оптимизация времени ответа webhook
- Кэширование результатов поиска (опционально)
- Оптимизация запросов к AI API
- Мониторинг использования API квот

## Этап 9: Документация и деплой

### 9.1 Документация
- Создать README.md с инструкциями по установке и настройке
- Документировать API endpoints
- Описать процесс настройки webhook
- Добавить примеры использования

### 9.2 Финальный деплой
- Деплой на Vercel
- Настройка production переменных окружения
- Установка webhook URL в Telegram
- Тестирование в production окружении

### 9.3 Мониторинг и логирование
- Настроить логирование ошибок
- Настроить мониторинг производительности
- Настроить алерты для критических ошибок

## Этап 10: Дополнительные улучшения (опционально)

### 10.1 Расширенные функции
- Поддержка медиа-файлов (изображения, видео)
- История запросов пользователя
- Кэширование результатов для похожих запросов
- Поддержка нескольких языков

### 10.2 UX улучшения
- Интерактивные кнопки в Telegram
- Прогресс-бар для долгих операций
- Улучшенное форматирование ответов
- Поддержка команд бота (/start, /help)


